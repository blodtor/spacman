/**
 * Link cable Protocol (LCP) - протокол для обмена данными через SEGA Link Cable
 * двух приставок Sega Mega Drive / Sega Genesis который втыкается в второй порт приставок
 * для SGDK 1.90 (July 2023)
 *
 * https://zt.ucoz.ru/_ph/9/174348130.jpg
 *
 * BlodTor 2025 г.
 */
#ifndef _LINK_CABLE_H_
#define _LINK_CABLE_H_

/**
 * Константы
 */

// Направление ввода/вывода 2 порта приставки SEGA MD (устанавливается для каждого бита в отдельности)
// определяет режим работы линий данных (ввод или вывод) и управляет маской запроса прерывания от внешних устройств.
// по сути это адрес памяти 0xa1000b для управления передачей данных
// через SEGA Link cable (Регистр CTRL порт CTRL 2 в документации SEGA)
// 7 бит (INT) - Прерывание по сигналу линии SYN. 0 - запрещено; 1 - разрешено.
// 6 бит (PC6) - В каком режиме линия данных “SYN”. 0 - ввода; 1 - вывода.
// 0 - 5 бит (PC0 - PC5) - в каком режиме линия данных. 0 - ввода; 1 - вывода.
#define LCP_Ctrl   				(*(vu8*) 0xa1000b)

// состояние 2 порта приставки SEGA MD
// посути это адрес в памяти 0xa10005 для непосредственной передачи данных
// через SEGA Link cable (Регистр DATA порт CTRL 2 в документации SEGA)
// Младшие 4 бита (0 - 3) используются для передачи данных
// 5 бит в текущей преставке это 6 бит в другой приставке для того же адреса памяти 0xa10005, если мы меняем 5 бит у нашей
// приставки на второй приставке изменится 6 ой бит в ее переменной LCP_Data и наоборот если в другой приставке
// будет изменен 5 бит в нашей приставке изменится 6ой бит
// 0 - 3 биты по адресу 0xa10005 в обоих приставках будут иметь одинаковое значение, т.е. если меняем на одной
// эти биты то и на другой они поменяются, а какая приставка за это в даный момент ответственна определяется LCP_Ctrl
// т.е. у какой линии данных в режиме вывода (отправляет данные) у какой линии в режиме ввода (получает данные)
#define LCP_Data   				(*(vu8*) 0xa10005)

// 5 бит выставлен в 1 остальные в 0, восновном используется для установки 5 биа в 1 у LCP_Data и LCP_Ctrl
// для сигнализации другой приставке что можно читать или отправлять данные через Link cable
#define LCP_BIT5				0b00100000

// 6 бит выставлен в 1 остальные в 0, восновном используется для определения
// выставлен или нет 6 бит у LCP_Data, сигнализирующий что
// можно читать данные от другой приставки или отправлять их другой приставке через Link cable
#define LCP_BIT6				0b01000000

// 7 и 5 бит выставлены в 1 остальные биты равны 0, используется для установки этих битов у LCP_Ctrl что значит
// готовы к обмену данными через 2 порт приставки по наступлению внешнего прерывания EX-INT - External interrupt
// в документации SEGA т.е. чтения данных из порта (получение данных) в обработчике внешних прерываний LCP_slaveCycle()
//
// Прерывание по сигналу линии SYN разрешено, 7 бит = 1.
// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
// включаем pin 0-3 2го порта контроллера для получения данных
// pin 5 для сигнала о том что данные получены нашей приставкой (у другой приставки это 6 бит LCP_Data будет)
// pin 6 сигнал о том что данные были отправлены другой приставкой (другая приставка должна менять 5 бит у своей LCP_Data)
#define	LCP_BIT7_AND_BIT5 		0b10100000;

// 5, 3, 2, 1, 0 биты выставлены в 1 остальные равны 0, используется для установки этих битов у LCP_Ctrl что значит
// начинаем цикал записи данных в 2 порт (передачи данных) по средствам вызова внешного прирывания у ведомой приставки (slave)
// т.е. у ведущей приставки (master) нужно из основного кода игры вызвать метод LCP_masterCycle() который установит у LCP_Ctrl
// биты в указанное выше состояние а у ведомой приставки мы перд этим вызовим внешнее прирывание которое остановит выполнение основного кода игры
// и вызовит метод LCP_slave(), произойдет это когда на ведущей приставке в LCP_Data 5ый бит будет сброшен в 0 в методе LCP_startSendCycle()
//
// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
// линия данных PC5, PC3, PC2, PC1, PC0 в режиме вывода (отправки), 5, 3 ,2, 1, 0 бит = 1.
// линии данных PC6, PC4 в режиме ввода (получения) . Соответствующие биты = 0
// включаем pin 0-3, 2го порта контроллера для отправки данных
// pin 5 для сигнала о том что данные можно считывать другой приставкой (у другой это 6 бит LCP_Data будет)
// pin 6 сигнал о том что данные были прочитаны другой приставкой (другая приставка должна менять 5 бит у своей LCP_Data)
#define LCP_BIT_5_3_2_1_0 		0b00101111;

// маска 00001111 восновном используется для сброса в 0 старших 4 бит в байте
#define LCP_LO_BITS 			0b00001111

// маска 11110000 восновном используется для сброса в 0 младших 4 бит в байте
#define LCP_HI_BITS  			0b11110000

// таймаут - используется для ожидания данных от другой приставки (ожидание сброса или установки 6 бита в LCP_Data)
#define LCP_TIME_OUT 			0x80

// максимальный размер пакета для передачи данных через Link cable
#define LCP_PACKET_SIZE			2048


/**
 * Деклорация функций библиотеки
 */


/**
 * Открытие 2 порта приставки для обмена данными через Link cable
 * при наступлении внешнего прерывания - External interrupt (EX-INT)
 * interrupt mask level 2 для Процессора 68000
 * установка Callback функции вызываемой при наступлении EX-INT прирывания
 */
void LCP_open();


/**
 * Инициализация 2 порта приставки для обмена данными через Link cable
 * для прямой записи в порт данных а затем чтения данных из порта
 * EX-INT прерывания запрещаем для этой приставки
 * сброс глобальных переменных
 */
void LCP_init();


/**
 * Закрытие порта приставки для обмена данными через Link cable
 * отключаем обработчик внешнего прерывания - External interrupt (EX-INT)
 * interrupt mask level 2 для процессора 68000
 */
void LCP_close();


/**
 * Функция для копирования передаваемого объекта transferObject - в виде байтового массива
 * в пакет LCP_sendPacket для передачи пакетов через Link cable
 * первые 2 байта в пакете содержат тип передаваемого объекта (не может быть равен 0)
 * далее в пакете идут данные (по 2 байта) объекта, согласно таблице размеров объектов objectTypeSizes
 * можно передавать несколько объектов за раз, главное чтоб они влезли в буфер
 * т.е. предполагается что функцию можно вызывать несколько раз подряд, пока не получим
 * ниже описанные ошибки
 *
 * если error & 0x000F == 0xC - размер передаваемого объекта отрицательный либо равен 0
 * если error & 0x000F == 0xD - размер передаваемого объекта больше оставшегося места в пакете
 * если error & 0x000F == 0xF - индекс начала данных в пакете больше индекса конца данных в пакете
 *
 * transferObject - отправляемый объект в виде байтового массива через Link cable
 * objectType - тип отправляемого объекта (число равеное номеру в массиве размеров объектов)
 * objectTypeSizes - массив размеров объектов (определяется в основном коде ВАШЕЙ игры)
 */
void LCP_objectToPacketForSend(u8 *transferObject, u16 objectType , u16 *objectTypeSizes);


/**
 * Функция достает очередной объект в виде байтового массива transferObject из полученного пакета LCP_recivePacket
 * через Link cable и возвращает тип этого объекта или 0 если объект не удалось достать из LCP_recivePacket
 * т.к. мы можем за 1 раз передать несколько объектов, предполагается возможным несколько раз подряд
 * вызывать данную функцию, пока не получем 0, что занчит - все объекты извлечены из переданного пакета
 *
 * первые 2 байта пакета в LCP_recivePacket содержат тип передаваемого объекта (не может быть равен 0)
 * далее в пакете идут данные (по 2 байта) объекта, согласно таблице размеров объектов objectSizes
 * можно передавать несколько объектов за раз, главное чтоб они влезли в массив LCP_recivePacket
 *
 * если error & 0xF000 == 0x1000 - нет объекта в полученном пакете, все дастали уже из пакета или нам ни чего не передали
 * если error & 0xF000 == 0x2000 - размер извлекаемго объекта из буфера прочитанных пакетов - отрицательный или равен 0
 * если error & 0xF000 == 0x3000 - размер извлекаемого объекта больше оставшихся данных в пакете полученных данных
 * если error & 0xF000 == 0x4000 - размер извлекаемого объекта больше оставшегося размера массива LCP_recivePacket
 *
 * transferObject - очередной полученный объект в виде байтового массива через Link cable
 * objectSizes - массив размеров объектов (определяется в основном коде ВАШЕЙ игры)
 *
 * return - тип полученного объекта или 0 если не удалось извлечь объект из полученного пакета
 */
u16 LCP_getNextObjectFromRecivePacket(u8 *transferObject, u16 *objectSizes);


/**
 * Цикл передачи а затем получения данных через Link cable ведущей приставки SEGA (master)
 * в самом начале отключаем обработку всех прирываний и сбрасываем LCP_timeOut и LCP_error в 0
 * и в случае ошибки и в случае успешном завершении функции, т.е. всегда в конце вызываем LCP_masterCycleEnd()
 * чтоб перевести 2 порт приставки в правильное состояние и включить обработку всех прерываний.
 *
 * если LCP_error & 0x00F0 = 0x10 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x20 - ошибка при вызове функции LCP_send(size) - передачи 2 байт (размера пакета) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x30 - ошибка при вызове функции LCP_send(data) - передачи 2 байт (данные пакета) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x40 - ошибка при вызове функции LCP_send(checksum) - передачи 2 байт (контрольной суммы) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x50 - ошибка при вызове функции LCP_endSendCycle() - конеца основного цикла передачи пакета от ведущей (master) ведомой (slave) приставке
 * если LCP_error & 0x00F0 = 0x60 - ошибка при вызове функции LCP_startReciveCycle() - начала цикл получения данных от ведомой приставки (slave) ведущей
 * если LCP_error & 0x00F0 = 0x70 - ошибка при вызове функции checksum = LCP_recive() - получение 2 байт (контрольной суммы пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0x80 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0x90 - ошибка при вызове функции size = LCP_recive()- получения 2 байт (размер пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xA0 - ошибка при вызове функции data = LCP_recive() - получения 2 байт (данные пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xB0 - ошибка при вызове функции checksum = LCP_recive() - основной цикл получения 2 байт (checksum) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xC0 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xD0 - ошибка при вызове функции LCP_endReciveCycle() - окончание цикла получения данных от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xE0 - ошибка при вызове функции LCP_startSendCycle() -  начало передачи контрольной суммы ведомой (slave) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0xF0 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы ведомой (slave) от ведущей (master)
 */
void LCP_masterCycle();


/**
 * Сбросить индексы начала и конеца данных в пакете для отправки через Link cable (массив LCP_sendPacket)
 */
void LCP_clearSendHeadAndTail();


/**
* Сбросить индексы начала и конеца данных в пакете для получения через Link cable (массив LCP_recivePacket)
*/
void LCP_clearReciveHeadAndTail();


/**
 * Возвращает индекс начала данных в массиве LCP_sendPacket
 *
 * return LCP_sendHead
 */
u16 LCP_getSendHead();


/**
 * Возврощает индекс конеца данных в массиве LCP_sendPacket
 *
 * return LCP_sendTail
 */
u16 LCP_getSendTail();


/**
 * Возвращает индекс начала данных в массиве LCP_recivePacke
 *
 * return LCP_reciveHead
 */
u16 LCP_getReciveHead();


/**
 * Возвращает индекс конеца данных в массиве LCP_recivePacket
 *
 * return u16 LCP_reciveTail
 */
u16 LCP_getReciveTail();


/**
 * Ошибка при передачи данных через SEGA Link cable
 *
 * return LCP_error
 */
u16 LCP_getError();

#endif // _LINK_CABLE_H
