/**
 * Link cable Protocol (LCP) - протокол для обмена данными через SEGA Link Cable
 * двух приставок Sega Mega Drive / Sega Genesis который втыкается в второй порт приставок
 * для SGDK 1.90 (July 2023)
 *
 * https://zt.ucoz.ru/_ph/9/174348130.jpg
 *
 * BlodTor 2025 г.
 */

#include "types.h"
#include "sys.h"
#include "vdp.h"
#include "z80_ctrl.h"
#include "memory.h"

#include "link_cable.h"

/**
 * Глобальные переменные
 */

// порт открыт или нет (порт CTRL 2 в документации SEGA - порт второго контроллера)
// если 1 - открыт, должно вызыватся внешнее прерывание  EX-INT - External interrupt в документации SEGA
// инициируемое другой приставкой которая по отношению к нашей будет ведущая (master),
// т.е. мы сначала получеаем данные из порта от ведущей (master) приставки
// а затем отправляем ей данные в одном цикле обмена данными.
// обработчик прерывания может быть вызван в любой момент у нашей ведомой приставки (slave)
// исполняемый код в момент прерывания будет приостановлен, а после выполнения обработчика прерывания
// регистры будут восстановлены и продолжется выполнение основного кода игры
// получение и отправка данных асинхронная по оношению к подготовке того что отправлять и обработке того что
// получили нашей ведомой приставкой (slave)
// если 0 - порт закрыт, ваша приставка не имеет обработчика внешних прерываний EX-INT  - External interrupt, но может вызывать
// это прерывание у другой приставки т.е. ваша приставка ведущая (master). Мы сначала отправляем данные ведомой
// приставке (slave) а затем получаем от нее данные в одном цикле обмена данными.
// Отправка и получение данных у нашей ведущей приставки (master) синхронное, из основного кода игры по отношению к
// подготовке того что надо отправить и обработке того что получили от другой ведомой приставки (slave)
static u16 LCP_portOpen = 0;


// индекс начала данных в массиве LCP_sendPacket, которые нужно передать через Link cable
// можем передавать несколько объектов, тут будет индекс первого байта первого
// не переданного объета в пакете LCP_sendPacket
static u16 LCP_sendHead = 0;


// индекс конеца данных в массиве LCP_sendPacket, которые нужно передать через Link cable
// можем передавать несколько объектов, тут будет последний байт последнего
// не переданного объекта в  пакете LCP_sendPacket
static u16 LCP_sendTail = 0;


// пакет для передачи данных - массив в который функция LCP_objectToPacketForSend складывает объекты для передачи через Link cable.
// делается это из основного цикла вашей игры когда надо другой приставке что то передать
// первые 16 бит это тип объекта, далее идут данные объекта и таких объектов может быть в пакете несколько.
//
// 0                       LCP_sendHead                                 LCP_sendTail                    LCP_PACKET_SIZE
// |   16 бит               |                                            |                                    |
// [тип объекта 1][объект1][тип объекта 2][объект2][тип объекта 3][объект3][][][][][][][][][][][][][][]][][]][]
static u16 LCP_sendPacket[LCP_PACKET_SIZE];


// индекс начала данных в массиве LCP_recivePacket, которые были получены через Link cable
// можем получить за раз несколько объектов, тут будет индекс первого байта первого
// полученного объекта в массиве LCP_recivePacket
static u16 LCP_reciveHead  = 0;


// индекс конеца данных в массиве LCP_recivePacket, которые были полученны через Link cable
// можем молучить несколько пакетов за раз, тут будет последний байт последнего
// полученного объекта в массиве LCP_recivePacket
static u16 LCP_reciveTail  = 0;


// пакет полученных данных - массив из которого функция LCP_getNextObjectFromRecivePacket в основном коде вашей игры копирует
// очередной полученный объект в transferObject (указатель на байтовый массив в коде вашей игры) и возвращает тип этого объекта.
// делается это в основном коде вашей игры, а вот данные в пакет попадают при работе Master цикла - LCP_masterCycle() для ведущей приставки
// или Slave цикла - LCP_slaveCycle() для ведомой приставки. Эти функции занимаются передачей данных через Link cable
// LCP_masterCycle() - всегда вызывается синхронно из основного кода вашей игры! И только у ведущей приставки (master)
// LCP_slaveCycle() - вызывается асинхронно при наступлении внешнего прирывания - External interrupt (EX-INT) только у ведомой приставки
//
// 0                       LCP_reciveHead                               LCP_reciveTail                LCP_PACKET_SIZE
// |   16 бит               |                                            |                                    |
// [тип объекта 1][объект1][тип объекта 2][объект2][тип объекта 3][объект3][][][][][][][][][][][][][][]][][]][]
static u16 LCP_recivePacket[LCP_PACKET_SIZE];


// TODO таймаут если при передачи данных была ошибка в конце взаимодействия
static u16 LCP_timeOutTime = 0;


// если отличен от 0 значит при получении или передаче младших 4 бит LCP_Data был обрыв связи
// и произошел таймаут ожидания данных, что конкретно можно понять по LCP_error
static u8 LCP_timeOut = 0;


// Ошибка - если 0000000000000000 значит ошибок небыло!                         диапазон значений  значение в двоичном виде
// 4 младших бита младшего байта - ошибки при получении данных через Link cable (0x0001 - 0x000F)  000000000000xxxx
// 4 старших бита младшего байта - ошибки при отправке  данных через Link cable (0x0010 - 0x00F0)  00000000xxxx0000
// 4 младших бита старшего байта - ошибки при полученнии или передаче пакетов   (0x0100 - 0x0F00)  0000xxxx00000000
// 4 старших бита старшего байта - ошибки при извлечении объекта из пакета      (0x1000 - 0xF000)  xxxx000000000000
static u16 LCP_error = 0;

/**
 * Начало цикла передачи данных размером 2 байта (16 бит) через Link cable
 * сбрасываем у LCP_Data 5ый бит в 0 - данные не готовы для чтения другой приставкой
 * выставляем LCP_Ctrl = 00101111 чем включем у 2 порта для контроллера
 * pin 0-3 для передачи данных а 5ый pin для сигнала о том что данные можно считывать
 * другой приставке как тока выставим его в 1 при этом ожидаем что на 6ом pin у нас 0
 * на момент вызова функции (если там 1 будем ждать 0ля пока не словим таймаут и кинем ошибку 0xA если не дождемся)
 *
 * если LCP_error & 0x000F == 0xA - ошибка при подготовке к передаче данных (не дождались 0 на 6 пине 2го контроллера)
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_startSendCycle();


/**
 * Основной цикл передачи данных размером 2 байта (16 бит) через Link cable
 * передается через LCP_Data - общая область памяти у обоих приставок
 * по 4 бита за 1 раз, т.е. в 4 итерации т.к. в 2 байтах = 16 бит
 * заполняет младшие 4 бита данных в LCP_Data которые отправляем
 * выставляет или сбрасывает 5 бит в зависимости от итерации в LCP_Data
 * ожидает в бите 6 у LCP_Data подтверждения получения данных другой приставкой
 * если не дожидается потверждения, сохраняет ошибку в LCP_error
 * если LCP_error & 0x000F == 0x1 - не дождались подтверждения получения данных 1 итерации
 * если LCP_error & 0x000F == 0x2 - не дождались подтверждения получения данных 2 итерации
 * если LCP_error & 0x000F == 0x3 - не дождались подтверждения получения данных 3 итерации
 * если LCP_error & 0x000F == 0x4 - не дождались подтверждения получения данных 4 итерации
 *
 * data - 2 байта данных (16 бит данных) которые хотим передать
 * пусть изначально data = "aaaayyyybbbbxxxx" разбил 2 байта (16 бит) по 4 бита
 * сначала передадим aaaa, потом yyyy, потом bbbb и в четвертой итерации xxxx
 *
 * на момент вызова функции LCP_Data = "r00rrrrr" - где r любое значение и на данный момент не важно какое
 * сначала должна была успешно завершится функция LCP_startSendCycle либо успешно завершится другая LCP_send
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_send(u16 data);


/**
 * Конец цикла передачи данных размером 2 байта (16 бит) через Link cable
 * выставляем LCP_Ctrl = 00100000 чем включем у 2 порта для контроллера
 * pin 0-3 для получения данных а 5ый pin для сигнала о том что наша SEGA готова принимать данные
 * сбрасываем у LCP_Data 5ый бит в 0, ждем подтверждения что другая приставка готоав посылать данные
 * пока в 6ом бите у LCP_Data не будет 1 или пока не словим таймаут и кинем ошибку 0xB если не дождемся
 *
 * если LCP_error & 0x000F == 0x5 - ошибка окончания цикла передачи данных (не дождались 1 в 6ом бите у LCP_Data)
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_endSendCycle();


/**
 * Начало цикла получения данных размером 2 байта (16 бит) через Link cable
 * Сбрасываем 5-й бит у LCP_Data в 0 (готовы к чтению)
 */
static void LCP_startReciveCycle();


/**
 * Основной цикл получения данных размером 2 байта (16 бит) через Link cable
 * получает по 4 бита за 4 итерации через LCP_Data (младшие 4 бита)
 * выставляет или сбрасывает 5 бит у LCP_Data в зависимости от итерации тем самым
 * подтверждая успешность чтения для приставки которая нам данные отправила
 * ожидает в бите 6 у LCP_Data подтверждения от другой приставки что данные можно читать
 *
 * если LCP_error & 0x000F = 0x5 - не дождались подтверждения что можно читать данные для 1 итерации
 * если LCP_error & 0x000F = 0x6 - не дождались подтверждения что можно читать данные для 2 итерации
 * если LCP_error & 0x000F = 0x7 - не дождались подтверждения что можно читать данные для 3 итерации
 * если LCP_error & 0x000F = 0x8 - не дождались подтверждения что можно читать данные для 4 итерации
 *
 * return - 2 байта данных (16 бит данных) которые получили от другой SEGA "aaaayyyybbbbxxxx"
 * 			если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static u16 LCP_recive();


/**
 * Конец цикла чтения данных размером 2 байта (16 бит) через Link cable
 * ждем подтверждения что другая приставка поняла про окончание приема данных от нашей приставки
 * пока в бите 6 у LCP_Data не будет 0 или пока не словим таймаут и кинем ошибку 0x9 если не дождемся
 * устанавливаем у LCP_Data 5ый бит в 1, получили подтверждение от другой SEGA MD что она удачно все передала
 *
 * если LCP_error & 0x000F == 0x9 - не дождались подтверждения что данные были получены другой SEGA
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_endReciveCycle();


/**
 * Окончание цикла передпчи и получения данных через Link cable ведущей приставки SEGA (master)
 * У LCP_Ctrl выставляем бит 5 в 1 остальные в 0 что означает что мы больше не передаем данные в 0 - 3 битах
 * у LCP_Data выставляем бит 5 в 1 для нашей ведущей (master) приставки, у другой приставки (slave) бит 6 станет тоже 1
 * включаем обработку всех прерываний
 */
static void LCP_masterCycleEnd();


/**
 * Цикл получения а затем передачи данных через Link cable ведомой приставки SEGA (slave)
 * Это обработчик внешнего прерывания EX-INT - External interrupt в документации SEGA
 * вызывать напрямую из кода игры его НЕЛЬЗЯ!
 *
 * Данная функция будет установлена в качестве обработчика внешних прирываний EX-INT при вызове функции LCP_open() из ВАШЕГО кода игры
 * и в качестве обработчика внешних прерываний будет отключена при вызове LCP_close() из ВЫШЕГО кода игры
 *
 * вызов функции всегда происходит как бы асинхронно, прерывая выполнение вашего кода игры в произвольное, рандомное время для основного кода игры!
 *
 * в самом начале отключает обработку всех прирываний и сбрасываем LCP_timeOut и LCP_error в 0
 *
 * если LCP_error & 0x0F00 = 0x100 - ошибка при вызове функции LCP_slaveCycle() - второй порт приставки не открыт для обмена данными
 * если LCP_error & 0x0F00 = 0x200 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x300 - ошибка при вызове функции size = LCP_recive() - получение размера переданных данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x400 - ошибка при вызове функции data = LCP_recive() - получение очередных 2 байта даных пакета от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x500 - ошибка при вызове функции checksum = LCP_recive() - получение контрольной суммы от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x80  - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x600 - ошибка при вызове функции LCP_endReciveCycle() - конец получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x700 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0x800 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0x900 - ошибка при вызове функции LCP_send(size) - передача размера передаваемого пакета от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xA00 - ошибка при вызове функции LCP_send(data) - передача очередных 2 байт данных из пакета от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xB00 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xC00 - ошибка при вызове функции LCP_endSendCycle() - конец передачи данных от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xD00 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0xE00 - ошибка при вызове функции data = LCP_recive() - получения контрольной суммы от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0xC0  - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
 */
static void LCP_slaveCycle();


/**
 * Конец цикла получения а затем передачи данных через Link cable ведомой приставки SEGA (slave)
 * переводит 2 порт приставки в режим получения данных через Link cable, на всех пинах кроме 5 го
 * У LCP_Ctrl выставляем бит 5 в 1 остальные в 0 что означает что мы больше не передаем данные в 0 - 3 битах
 * у LCP_Data выставляем бит 5 в 1 для нашей ведомой (slave) приставки, у другой приставки (master) бит 6 станет тоже 1
 * включает обратно обработку всех прерываний
 *
 * если LCP_error & 0x0F00 = 0xF00 - шибка при вызове функции LCP_slaveCycleEnd() - окончание цикла получения данных от ведомой приставки (slave)
 */
static void LCP_slaveCycleEnd();


/**
 * Реализация функций библиотеки
 */

/**
 * Открытие 2 порта приставки для обмена данными через Link cable
 * при наступлении внешнего прерывания - External interrupt (EX-INT)
 * interrupt mask level 2 для Процессора 68000
 * установка Callback функции вызываемой при наступлении EX-INT прирывания
 */
void LCP_open() {

    // захватить шины сопроцессора Z80
	//
	// Записать слово $0100 по адресу $A11100
	// и ждем в цикле пока бит D8 не станет равным 0
    bool busTaken = Z80_getAndRequestBus(TRUE);

    // Отключение прирываний через SR - Status Register, т.к. будет выставлен interrupt mask level 7 для процессора 6800
    //
    // вот так Status Register выглядит:
    // Bit 15 14 13 12 11 10  9  8   7  6  5  4  3  2  1  0
    //    ---------------------------------------------------
    //    | T| -| S| -| -| I2,I1,I0 | -| -| -| X| N| Z| V| C|
    //    ---------------------------------------------------
    // I2, I1, I0 - маски  прерываний,  определяет  минимальный  уровень  обслуживамых  запросов  прерывания
    //
    // всего типов прерываний 3: EX-INT, H-INT, V-INT
    //
	//  		| I2 | I1 | I0 |
	//
	//	level 0 |  0    0    0 |  ---------> lowest priority
	//	level 1 |  0    0    1 |
	//	level 2 |  0    1    0 |  External interrupt (EX-INT)
	//	level 3 |  0    1    1 |
	//	level 4 |  1    0    0 |  Horizontal interrupt (H-INT)
	//	level 5 |  1    0    1 |
	//	level 6 |  1    1    0 |  Vertical interrupt (V-INT)
	//	level 7 |  1    1    1 |  ---------> highest priority
    //
    // при установке 7 = т.е. двоичное 111, I2 = 1, I1 = 1, I0 = 1
    // игнорируются все прерывания, т.к. их уровни все ниже
    SYS_setInterruptMaskLevel(7);

    // устанавливаем функцию которая будет вызыватся при возникновении
    // внешнего прерывания EX-INT - External interrupt
    // т.е. выполнение кода игры будет прервано при возникновении прирывания EX-INT, состояние регистров будет сохранено
    // после чего  вызовется  переданная в SYS_setExtIntCallback функция - LCP_slaveCycle(), по завершению состояние регистров востанавливается и
    // будет выполнен код игры с того места где он был прерван
    SYS_setExtIntCallback(LCP_slaveCycle);

    // Разрешаем внешнее прерывание (interrupt mask level 2 для процессора 68000)
    //
    // 11 регистр выглядит так:
    // Bit  7   6   5   4    3      2      1     0
    //    | - | - | - | - | IE2 | VSCR | HSCR | LSCR |
    //
    // Установка регистра 11 в 8 или в двоичном виде в 00001000
    // т.е. флаги примут такие значения:
    // VSCR = 0 - режим вертикальной прокрутки = ПОЛНАЯ ПРОКРУТКА
    // HSCR = 0, LSCR = 0 - режим горизонтальной прокрутки = ПОЛНАЯ ПРОКРУТКА
    // IE2  = 1 - разрешает внешнее прерывание (level 2 для 68000 External interrupt - EX-INT)
	VDP_setReg(11, 8);

	// готовы к обмену данными через 2 порт приставки по наступлению EX-INT прерывания
	// сначала чтения данных из порта потом записи в порт в обработчике внешних прерываний LCP_slaveCycle()
	// Прерывание по сигналу линии SYN разрешено, 7 бит = 1.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала о том что данные получены нашей приставкой (у другой приставки это 6 бит LCP_Data будет)
	// pin 6 сигнал о том что данные были отправлены другой приставкой (другая приставка должна менять 5 бит у своей LCP_Data)
	LCP_Ctrl = LCP_BIT7_AND_BIT5;

    // Устанавливаем 5-й бит в 1 у LCP_Data (у другой приставки 6 бит станет равен 1 в LCP_Data)
	LCP_Data |= LCP_BIT5;

	// признак того что порт открыт и обмен данными после наступлению EX-INT прерывания разрешен
	LCP_portOpen = 1;

    // Включаем все прерывания прерывания через SR - Status Register
	//
    // устанавливаем level 1 для процессора 68000, что означает все прерывания будут отрабатывать
	// т.к. их маска выше 1
	SYS_setInterruptMaskLevel(1);


    if (!busTaken) {
        // освобождаем шину Z80
    	// записать слово $0000 по адресу $A11100
    	Z80_releaseBus();
    }

}


/**
 * Инициализация 2 порта приставки для обмена данными через Link cable
 * для прямой записи в порт данных а затем чтения данных из порта
 * EX-INT прерывания запрещаем для этой приставки
 * сброс глобальных переменных
 */
void LCP_init() {
    // обнуляем LCP_sendHead и LCP_sendTail
	LCP_clearSendHeadAndTail();

	// обнуляем LCP_reciveHead и LCP_reciveTail
	LCP_clearReciveHeadAndTail();

    // Установка таймаута
	LCP_timeOutTime = 0;

    // сброс ошибок
    LCP_error = 0;

	 // захватить шины сопроцессора Z80
    bool busTaken = Z80_getAndRequestBus(TRUE);

    // признак того что порт инициализирован и обмен данными начинается с записи в порт без ожидания наступления внешнего прерывания
    // т.е. мы вызываем внешнее прерывание у другой приставки и после цикла записи в порт начинаем читать данные из порта
    LCP_portOpen = 0;

    // Отключение всех прирываний кроме V-INT через SR - Status Register, т.к. будет выставлен interrupt mask level 2 для процессора 6800
    //
    // вот так Status Register выглядит:
    // Bit 15 14 13 12 11 10  9  8   7  6  5  4  3  2  1  0
    //    ---------------------------------------------------
    //    | T| -| S| -| -| I2,I1,I0 | -| -| -| X| N| Z| V| C|
    //    ---------------------------------------------------
    // I2, I1, I0 - маски  прерываний,  определяет  минимальный  уровень  обслуживамых  запросов  прерывания
    //
    // всего типов прерываний 3: EX-INT, H-INT, V-INT
    //
	//  		| I2 | I1 | I0 |
	//
	//	level 0 |  0    0    0 |  ---------> lowest priority
	//	level 1 |  0    0    1 |
	//	level 2 |  0    1    0 |  External interrupt (EX-INT)
	//	level 3 |  0    1    1 |
	//	level 4 |  1    0    0 |  Horizontal interrupt (H-INT)
	//	level 5 |  1    0    1 |
	//	level 6 |  1    1    0 |  Vertical interrupt (V-INT)
	//	level 7 |  1    1    1 |  ---------> highest priority
    SYS_setInterruptMaskLevel(5);


    // Запрещаем внешнее прерывание (interrupt mask level 2 для процессора 68000)
    //
    // Установка регистра 11 в 0, т.е:
    // VSCR = 0 - режим вертикальной прокрутки = ПОЛНАЯ ПРОКРУТКА
    // HSCR = 0, LSCR = 0 - режим горизонтальной прокрутки = ПОЛНАЯ ПРОКРУТКА
    // IE2  = 0 - запрещает внешнее прерывание (level 2 для процессора 68000 External interrupt - EX-INT)
    VDP_setReg(11, 0);

    // готовы к обмену данными через 2 порт приставки не по наступлению прерывания, а
    // по средствам прямой записи в порт а затем чтения из него. для этого в вашем коде игры надо использовать LCP_masterCycle()
    //
	// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала другой приставке о событии (у другой 6 бит LCP_Data будет равен тому что мы у нашей выставили в 5ом)
    // pin 6 сигнал от другой приставки о событии (другая приставка должна менять 5 бит у своей LCP_Data чтоб у нашей менялся 6ой)
    LCP_Ctrl = LCP_BIT5;

    // Устанавливаем 5-й бит в 1 у LCP_Data (у другой приставки 6 бит станет равен 1 в LCP_Data)
    LCP_Data |= LCP_BIT5;

    if (!busTaken) {
    	// освобождаем шину Z80
    	// записать слово $0000 по адресу $A11100
    	Z80_releaseBus();
    }
}


/**
 * Закрытие порта приставки для обмена данными через Link cable
 * отключаем обработчик внешнего прерывания - External interrupt (EX-INT)
 * interrupt mask level 2 для процессора 68000
 */
void LCP_close() {
	// отключаем обработчик внешних прерываний  EX-INT - External interrupt в документации SEGA
	SYS_setExtIntCallback(NULL);
	// сбрасываем состояние LCP
	LCP_init();
}


/**
 * Сбросить индексы начала и конеца данных в пакете для отправки через Link cable (массив LCP_sendPacket)
 */
void LCP_clearSendHeadAndTail() {
	LCP_sendHead = 0;
	LCP_sendTail = 0;
}


/**
* Сбросить индексы начала и конеца данных в пакете для получения через Link cable (массив LCP_recivePacket)
*/
void LCP_clearReciveHeadAndTail() {
	LCP_reciveHead  = 0;
	LCP_reciveTail  = 0;
}


/**
 * Начало цикла передачи данных размером 2 байта (16 бит) через Link cable
 * сбрасываем у LCP_Data 5ый бит в 0 - данные не готовы для чтения другой приставкой
 * выставляем LCP_Ctrl = 00101111 чем включем у 2 порта для контроллера
 * pin 0-3 для передачи данных а 5ый pin для сигнала о том что данные можно считывать
 * другой приставке как тока выставим его в 1 при этом ожидаем что на 6ом pin у нас 0
 * на момент вызова функции (если там 1 будем ждать 0ля пока не словим таймаут и кинем ошибку 0xA если не дождемся)
 *
 * если LCP_error & 0x000F == 0xA - ошибка при подготовке к передаче данных (не дождались 0 на 6 пине 2го контроллера)
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_startSendCycle() {

    // Сброс 5-го бита - данные пока не готовы для чтения другой приставкой
    LCP_Data &= ~(1 << 5);
    // LCP_Data = "r10rrrrr" - где r лубое значение и на данный момени не важно какое

    // задаем таймаут для ожидания 0 в бите 6 у LCP_Data
    u16 timeout = LCP_TIME_OUT;

     do {
	    timeout--;
	    if (timeout == 0) {
	    	// не дождались 0 на 6 пине 2го контроллера
	        LCP_timeOut++;
	        // ошибка при подготовке к передаче данных
	        LCP_error = 0xA;
	        return;
	    }
	} while (LCP_Data & LCP_BIT6); // ждем пока 6 бит не станет равным 0 в LCP_Data

    // LCP_Data = "r00rrrrr" - где r любое значение и на данный момент не важно какое

    // начинаем цикал записи данных в 2 порт в LCP_Ctrl записываем '00101111'
 	// прерывание по сигналу линии SYN запрещено, 7 бит = 0.
 	// линия данных PC5, PC3, PC2, PC1, PC0 в режиме вывода (отправки), 5, 3 ,2, 1, 0 бит = 1.
 	// линии данных PC6, PC4 в режиме ввода (получения) . Соответствующие биты = 0
    // включаем pin 0-3, 2го порта контроллера для отправки данных
    // pin 5 для сигнала о том что данные можно считывать другой приставкой (у другой это 6 бит LCP_Data будет)
    // pin 6 сигнал о том что данные были прочитаны другой приставкой (другая приставка должна менять 5 бит у своей LCP_Data)
	LCP_Ctrl = LCP_BIT_5_3_2_1_0;
}


/**
 * Основной цикл передачи данных размером 2 байта (16 бит) через Link cable
 * передается через LCP_Data - общая область памяти у обоих приставок
 * по 4 бита за 1 раз, т.е. в 4 итерации т.к. в 2 байтах = 16 бит
 * заполняет младшие 4 бита данных в LCP_Data которые отправляем
 * выставляет или сбрасывает 5 бит в зависимости от итерации в LCP_Data
 * ожидает в бите 6 у LCP_Data подтверждения получения данных другой приставкой
 * если не дожидается потверждения, сохраняет ошибку в LCP_error
 *
 * если LCP_error & 0x000F == 0x1 - не дождались подтверждения получения данных 1 итерации
 * если LCP_error & 0x000F == 0x2 - не дождались подтверждения получения данных 2 итерации
 * если LCP_error & 0x000F == 0x3 - не дождались подтверждения получения данных 3 итерации
 * если LCP_error & 0x000F == 0x4 - не дождались подтверждения получения данных 4 итерации
 *
 * data - 2 байта данных (16 бит данных) которые хотим передать
 * пусть изначально data = "aaaayyyybbbbxxxx" разбил 2 байта (16 бит) по 4 бита
 * сначала передадим aaaa, потом yyyy, потом bbbb и в четвертой итерации xxxx
 *
 * на момент вызова функции LCP_Data = "r00rrrrr" - где r любое значение и на данный момент не важно какое
 * сначала должна была успешно завершится функция LCP_startSendCycle либо успешно завершится другая LCP_send
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_send(u16 data) {
	// таймаут
	u16 timeout;

	// временная переменная для манипуляций с тем что в LCP_Data
	u8 tmp = 0;

	// i - итерация передачи данных (всего их четыре итерации)
	u8 i = 1;
	do {
		// циклический сдвиг влево на 4 (теперь в младших 4 битах данные которые хотим передать)
		// data = "aaaayyyybbbbxxxx" было для i = 1,  для i = 3 было   data = "bbbbxxxxaaaayyyy"
		data = (data << 4) | (data >> 12);
		// data = "yyyybbbbxxxxaaaa" стало для i = 1, для i = 3 стало  data = "xxxxaaaayyyybbbb"
		// будем передавать aaaa или bbbb в зависимости от итерации 1 или 3
		tmp = LCP_Data;
		// записываем 4 бита которые хотим передать в младшие 4 бита LCP_Data
	    // старшие 4 бита из LCP_Data оставляем на месте т.е. (LCP_Data & 11110000)
		// а младшие 4 бита LCP_Data будут младшие 4 бита из data т.е. (data & 00001111)
		// LCP_Data = (LCP_Data & 11110000) | (data & 00001111)
		tmp = (tmp & LCP_HI_BITS) | (data & LCP_LO_BITS);
		LCP_Data = tmp;
		// после выполнения этой опирации:
		// LCP_Data = "r00raaaa" для i = 1, LCP_Data = "r00rbbbb" для i = 3

		// первая и третья итерация передачи данных другой SEGA
		// устанавливаем у LCP_Data 5 бит в 1 (сигнал что данные можно читать другой SEGA)
		LCP_Data |= (1 << 5);
		// LCP_Data = "r01raaaa" для i = 1, LCP_Data = "r01rbbbb" для i = 3
		// У другой SEGA в LCP_Data изменится значение 6го бита в 1, т.к. 5 пин нашего второго порта контроллера
		// соеденен с 6 пином второго контроллега другой SEGA

		// устанавливаем таймаут
		timeout = LCP_TIME_OUT;

		// Ждем что данные были прочитанны другой SEGA
		do {
			// умешаем значение timeout на 1
			timeout--;
			if (timeout == 0) {
				// не дождались сигнала от другой SEGA что данные были прочитанны
				// Увеличиваем LCP_timeOut на 1
				LCP_timeOut++;

				// в LCP_error записываем i которое равно 1 или 3 (итерация)
				LCP_error = i;
			    // LCP_error == 0x1 - не дождались подтверждения получения данных 1 итерации
				// LCP_error == 0x3 - не дождались подтверждения получения данных 3 итерации

				// Завершаем выполнение функции с ошибкой, LCP_error != 0
				return;
			}
		  // ждем пока 6 бит не станет равным 1 в LCP_Data (сигнал что данные прочитаны другой SEGA)
		  // У другой SEGA в LCP_Data значение 5го бита должны установить в 1, т.к. ее 5 пин второго порта контроллера
		  // соеденен с 6 пином второго контроллега нашей SEGA, и как там в 5ом выставят 1 у нашей 6ой бит тоже станет 1
		} while (!(LCP_Data & LCP_BIT6));
		// итерация передачи данных прошла успешно,
		// передали по Link cable "aaaa" для первой итерации или "bbbb" для третей итерации
		// LCP_Data = "r11raaaa" для i = 1, LCP_Data = "r11rbbbb" для i = 3

		// увеличиваем номер итерации
		i++;
		// теперь i = 2 или i = 4

		// циклический сдвиг влево на 4 (теперь в младших 4 битах следующие данные которые хотим передать)
		// data = "yyyybbbbxxxxaaaa" было для i = 2,  для i = 4 было   data = "xxxxaaaayyyybbbb"
		data = (data << 4) | (data >> 12);
		// data = "bbbbxxxxaaaayyyy" стало для i = 2, для i = 4 стало  data = "aaaayyyybbbbxxxx"
		tmp = LCP_Data;
		// записываем 4 бита которые хотим передать в младшие 4 бита LCP_Data
	    // Cтаршие 4 бита из LCP_Data оставляем на месте т.е. (LCP_Data & 11110000)
		// а младшие 4 бита LCP_Data будут младшие 4 бита из data т.е. (data & 00001111)
		// LCP_Data = (LCP_Data & 11110000) | (data & 00001111)
		tmp = (tmp & LCP_HI_BITS) | (data & LCP_LO_BITS);
		LCP_Data = tmp;
		// после выполнения этой опирации:
		// LCP_Data = "r11ryyyy" для i = 2, LCP_Data = "r00rxxxx" для i = 4

		// вторая и четвертая итерация передачи данных другой SEGA
		// устанавливаем у LCP_Data 5 бит в 0 (сигнал что данные можно читать другой SEGA)
		LCP_Data &= ~(1 << 5);
		// LCP_Data = "r10ryyyy" для i = 2, LCP_Data = "r10rxxxx" для i = 4


		// устанавливаем таймаут заново
		timeout = LCP_TIME_OUT;

		// Ждем что данные были прочитанны другой SEGA
		do {
			// умешаем значение timeout на 1
			timeout--;
			if (timeout == 0) {
				// не дождались сигнала от другой SEGA что данные были прочитанны
				// Увеличиваем LCP_timeOut на 1
				LCP_timeOut++;

				// в LCP_error записываем i которое равно 2 или 4 (итерация)
				LCP_error = i;
				// LCP_error == 0x2 - не дождались подтверждения получения данных 2 итерации
				// LCP_error == 0x4 - не дождались подтверждения получения данных 4 итерации

				// Завершаем выполнение функции с ошибкой, LCP_error != 0
				return;
			}
		// ждем пока 6 бит не станет равным 0 в LCP_Data (сигнал что данные прочитаны другой SEGA)
		} while (LCP_Data & LCP_BIT6);
		// итерация передачи данных прошла успешно,
		// передали по Link cable "yyyy" для второй итерации или "xxxx" для четвертой итерации
		// LCP_Data = "r00ryyyy" для i = 1, LCP_Data = "r00rxxxx" для i = 3

		// увеличиваем номер итерации
		i++;
		// теперь i = 3 для второй итерации или i = 5 для четвертой итерации

	  // продолжаем пока i не станет 5, значит все передали выходим (2 цикла всего - по 2 итерации передачи)
	} while (i < 5);
}


/**
 * Конец цикла передачи данных размером 2 байта (16 бит) через Link cable
 * выставляем LCP_Ctrl = 00100000 чем включем у 2 порта для контроллера
 * pin 0-3 для получения данных а 5ый pin для сигнала о том что наша SEGA готова принимать данные
 * сбрасываем у LCP_Data 5ый бит в 0, ждем подтверждения что другая приставка готоав посылать данные
 * пока в 6ом бите у LCP_Data не будет 1 или пока не словим таймаут и кинем ошибку 0xB если не дождемся
 *
 * если LCP_error & 0x000F == 0x5 - ошибка окончания цикла передачи данных (не дождались 1 в 6ом бите у LCP_Data)
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_endSendCycle() {
	// устанавливаем таймаут
	u16 timeout = LCP_TIME_OUT;

    // переводим порт в режим чтения данных
	// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала другой приставке о событии (у другой 6 бит LCP_Data будет равен тому что мы у нашей выставили в 5ом)
    // pin 6 сигнал от другой приставки о событии (другая приставка должна менять 5 бит у своей LCP_Data чтоб у нашей менялся 6ой)
    LCP_Ctrl = LCP_BIT5;

    // Сброс 5-го бита в 0 у LCP_Data
    LCP_Data &= ~(1 << 5);
    // LCP_Data = "r00rrrrr" - где r любое значение и на данный момент не важно какое


    // Ждем что в 6м бите у LCP_Data должна появится 1, другая SEGA готова к отправке данных
    // а наша приставка готова к получению
    do {
    	// умешаем значение timeout на 1
	    timeout--;
	    if (timeout == 0) {
	    	// не дождались 1 в 6ом бите у LCP_Data, значит вторая SEGA не готова к отправке данных
	        LCP_timeOut++;
	        // 0x5 - ошибка окончания цикла передачи данных
	        LCP_error = 0xB;
	        // Завершаем выполнение функции с ошибкой, LCP_error != 0
	        return;
	    }

	  // ждем пока 6 бит не станет равным 1 в LCP_Data (сигнал что другая SEGA готова к отправке ншей SEGA данных)
	} while (!(LCP_Data & LCP_BIT6));

    // LCP_Data = "r10rrrrr" - где r любое значение и на данный момент не важно какое

    // предпологается что после выполнения этой функции если мы хотим прочитать данные по Link cable
    // мы должны вызвать LCP_startReciveCycle()
}


/**
 * Начало цикла получения данных размером 2 байта (16 бит) через Link cable
 * Сбрасываем 5-й бит у LCP_Data в 0 (готовы к чтению)
 */
static void LCP_startReciveCycle() {
	/** TODO этот цикл не нужен, т.к. с получения данных начинает ведомая приставка (slave) по наступлению внешнего прерывания
		TODO и на момент вызова этой функции ведущая приставка (master) уже выставила
		TODO 6 бит равным 0 у ведомой приставки! А когда ведущая начинает цикл получения данных
		TODO она сразу должна сообщить что готова к чтению, ни чего не ожитая от ведомой (slave)

	// устанавливаем таймаут
	u16 timeout = LCP_TIME_OUT;

    // Ждем что в 6м бите у LCP_Data должна появится 0, другая SEGA отправила данные
    do {
    	// умешаем значение timeout на 1
        timeout--;
        if (timeout == 0) {
			// не дождались сигнала от другой SEGA что данные были отправлены нашей
			// Увеличиваем LCP_timeOut
            LCP_timeOut++;

            // в error записываем i которое равно 6 или 8 (2 или 4 итерация)
            LCP_error = 0xE;
            // LCP_error == 0x6 - не дождались подтверждения что можно читать данные для 2 итерации
            // LCP_error == 0x8 - не дождались подтверждения что можно читать данные для 4 итерации

            // Если timeout стал равен 0, выходим из цикла и возвращаем то что сейчас в data
            return;
			// data = "000000000000aaaa" для 1 итерации (i = 6)
			// или data = "0000aaaayyyybbbb" для третей итерации (i = 8)
        }
	// цикл продолжается пока 6 бит не станет равным 0 - сигнал от другой SEGA что данные можно читать нашей
	// У другой SEGA в LCP_Data значение 5го бита должны установить в 0, т.к. ее 5 пин второго порта контроллера
	// соеденен с 6 пином второго контроллега нашей SEGA, и как там в 5ом выставят 0 у нашей 6ой бит тоже станет 0
	} while (LCP_Data & BIT6);

	    TODO цикл не удалил, на случай если надо синхронно из основного кода запускать, тогда это нужно будет
	*/

    // Сбрасываем 5-й бит в LCP_Data (готовы к чтению)
    LCP_Data &= ~(1 << 5);
    // LCP_Data = "r00rrrrr" - где r любое значение и на данный момент не важно какое
}


/**
 * Основной цикл получения данных размером 2 байта (16 бит) через Link cable
 * получает по 4 бита за 4 итерации через LCP_Data (младшие 4 бита)
 * выставляет или сбрасывает 5 бит у LCP_Data в зависимости от итерации тем самым
 * подтверждая успешность чтения для приставки которая нам данные отправила
 * ожидает в бите 6 у LCP_Data подтверждения от другой приставки что данные можно читать
 *
 * если LCP_error & 0x000F = 0x5 - не дождались подтверждения что можно читать данные для 1 итерации
 * если LCP_error & 0x000F = 0x6 - не дождались подтверждения что можно читать данные для 2 итерации
 * если LCP_error & 0x000F = 0x7 - не дождались подтверждения что можно читать данные для 3 итерации
 * если LCP_error & 0x000F = 0x8 - не дождались подтверждения что можно читать данные для 4 итерации
 *
 * return - 2 байта данных (16 бит данных) которые получили от другой SEGA "aaaayyyybbbbxxxx"
 * 			если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static u16 LCP_recive() {
	// тут будут прочитанные данные от другой SEGA, переменная размером 16 бит (2 байта)
	u16 data = 0;
	// data = "0000000000000000"

	// временная переменная для манипуляций с тем что в LCP_Data
	u8 tmp = 0;

	// таймаут
	u16 timeout;

	// итерация передачи данных (всего четыре итерации)
	// а начинаю с 5, чтоб ошибка при получении отличалась от ошибки при передаче
	// 5 - первая итерация получения, 6 - вторая, 7 - треться, 8 - червертая итерация получения данных
	u8 i = 5;

	do {
		// устанавливаем таймаут
		timeout  = LCP_TIME_OUT;

		// Ждем что в бите 6 у LCP_Data должна появится 1, другая SEGA отправила данные
		do {
			// умешаем значение timeout на 1
			timeout--;
			if (timeout == 0) {
				// не дождались сигнала от другой SEGA что данные были отправлены нашей
				// Увеличиваем LCP_timeOut
				LCP_timeOut++;

				// в LCP_error записываем i которое равно 5 или 7 (1 или 3 итерация)
				LCP_error = i;
				// LCP_error == 0x5 - не дождались подтверждения что можно читать данные для 1 итерации
				// LCP_error == 0x7 - не дождались подтверждения что можно читать данные для 3 итерации

				// Если timeout стал равен 0, выходим из цикла и возвращаем то что сейчас в data
				return data;
				// data = "0000000000000000" для 1 итерации (i = 5)
				// или data = "00000000aaaayyyy" для третей итерации (i = 7)
			}
		// цикл продолжается пока 6 бит не станет равным 1 - сигнал от другой SEGA что данные можно читать нашей
	    // У другой SEGA в LCP_Data значение 5го бита должны установить в 1, т.к. ее 5 пин второго порта контроллера
		// соеденен с 6 пином второго контроллега нашей SEGA, и как там в 5ом выставят 1 у нашей 6ой бит тоже станет 1
		} while (!(LCP_Data & LCP_BIT6));
		// итерация получения данных прошла успешно,
		// получили по Link cable "aaaa" для первой итерации или "bbbb" для третей итерации
		// LCP_Data = "r10raaaa" для i = 5, LCP_Data = "r10rbbbb" для i = 7
		// временная переменная для манипуляций с тем что в LCP_Data
		tmp = LCP_Data;
		// теперь полученные 4 бита нужно сохранить в data
		// для этого мы сдвигаем все биты у data влево на 4 бита (data << 4)
		// для первой итерации это не имеет смысла т.к. там 0 но для третей (i = 7) мы "00000000aaaayyyy" преарвтим в "0000aaaayyyy0000"
		// теперь возьмем у LCP_Data только 4 младших бита (LCP_Data & 00001111) и солжим с тем что получилось в первом выражении
		data = (data << 4) | (tmp & LCP_LO_BITS);
		// data = "000000000000aaaa" для первой итерации (i == 5), "0000aaaayyyybbbb" для третей итерации (i == 7)

		// первая или вторая итерация получения данных от другой SEGA завершена, данные сохранены в data
		// устанавливаем у LCP_Data 5 бит в 1 (прочитали данные сообщаем об этом другой SEGA)
		LCP_Data |= (1 << 5);
		// LCP_Data = "r11raaaa" для первой итерайии (i == 5) или LCP_Data = "r11rbbbb" для третей итерации (i == 7)


		// увеличиваем номер итерации
		i++;
		// теперь i = 6 для второй итерации или i = 8 для четвертой

	    // Снова устанавливаем таймаут
	    timeout = LCP_TIME_OUT;

	    // Ждем что в бите 6 у LCP_Data должна появится 0, другая SEGA отправила данные
	    do {
	    	// умешаем значение timeout на 1
	        timeout--;
	        if (timeout == 0) {
				// не дождались сигнала от другой SEGA что данные были отправлены нашей
				// Увеличиваем LCP_timeOut
	            LCP_timeOut++;

	            // в LCP_timeOut записываем i которое равно 6 или 8 (2 или 4 итерация)
	            LCP_error = i;
	            // LCP_timeOut == 0x6 - не дождались подтверждения что можно читать данные для 2 итерации
	            // LCP_timeOut == 0x8 - не дождались подтверждения что можно читать данные для 4 итерации

	            // Если timeout стал равен 0, выходим из цикла и возвращаем то что сейчас в data
	            return data;
				// data = "000000000000aaaa" для 1 итерации (i = 6)
				// или data = "0000aaaayyyybbbb" для третей итерации (i = 8)
	        }
		// цикл продолжается пока 6 бит не станет равным 0 - сигнал от другой SEGA что данные можно читать нашей
		// У другой SEGA в LCP_Data значение 5го бита должны установить в 0, т.к. ее 5 пин второго порта контроллера
		// соеденен с 6 пином второго контроллега нашей SEGA, и как там в 5ом выставят 0 у нашей 6ой бит тоже станет 0
		} while (LCP_Data & LCP_BIT6);
		// итерация получения данных прошла успешно,
		// получили по Link cable "yyyy" для второй итерации или "xxxx" для четвертой итерации
		// LCP_Data = "r01ryyyy" для i = 6, LCP_Data = "r01rxxxx" для i = 8
	    tmp = LCP_Data;
		// теперь полученные 4 бита нужно сохранить в data
		// для этого мы сдвигаем все биты у data влево на 4 бита (data << 4)
		// для второй итерации (i == 6)  мы "000000000000aaaa" преарвтим в "00000000aaaa0000"
	    // для четвертой итерации (i = 8) мы "0000aaaayyyybbbb" преарвтим в "aaaayyyybbbb0000"
		// возьмем у LCP_Data только 4 младших бита (LCP_Data & 00001111) и солжим с тем что получилось в первом выражении
	    data = (data << 4) | (tmp & LCP_LO_BITS);
		// data = "00000000aaaayyyy" для второй итерации (i == 6), "aaaayyyybbbbxxxx" для четвертой итерации (i == 8)

		// вторая или четвертая итерация получения данных от другой SEGA завершена, данные сохранены в data
		// устанавливаем у LCP_Data 5 бит в 0 (прочитали данные сообщаем об этом другой SEGA)
	    LCP_Data &= ~(1 << 5);
	    // LCP_Data = "r00ryyyy" для первой итерайии (i == 6) или LCP_Data = "r00rxxxx" для третей итерации (i == 8)

	    // увеличиваем номер итерации
	    i++;
	    // теперь i = 7 для второй итерации или i = 9 для четвертой

	// продолжаем пока i не станет 9, значит все получили выходим (2 цикла всего - по 2 итерации получения)
	} while( i < 9);


	// возвращаем прочитанные 2 байта (16 бит) через Link cable
    return data;
}


/**
 * Конец цикла чтения данных размером 2 байта (16 бит) через Link cable
 * ждем подтверждения что другая приставка поняла про окончание приема данных от нашей приставки
 * пока в бите 6 у LCP_Data не будет 0 или пока не словим таймаут и кинем ошибку 0x9 если не дождемся
 * устанавливаем у LCP_Data 5ый бит в 1, получили подтверждение от другой SEGA MD что она удачно все передала
 *
 * если LCP_error & 0x000F == 0x9 - не дождались подтверждения что данные были получены другой SEGA
 *
 * если небыло ошибок (LCP_error == 0 и LCP_timeOut == 0)
 */
static void LCP_endReciveCycle() {
	// устанавливаем timeout
	u16 timeout = LCP_TIME_OUT;

	// ждем что дугая приставка SEGA MD поняла что мы успешно прочитали все 2 байта данных от нее
    do {
    	// умешаем значение timeout на 1
        timeout--;
        if (timeout == 0) {
            LCP_timeOut++;
            // 0x9 - не дождались подтверждения что данные были получены другой SEGA
            LCP_error = 0x9;
			// выходим из функции с ошибкой в error и LCP_timeOut > 0
            return;
        }
      // цикл продолжается пока 6 бит у LCP_Data не станет равным 0 - сигнал от другой SEGA что данные были прочитанны
	} while (LCP_Data & LCP_BIT6);

    // после выхода из цикла
    // LCP_Data = "r00rxxxx"

    // устанавливаем у LCP_Data 5 бит в 1 - получили подтверждение от другой SEGA, что она удачно все передала
    // LCP_Data = "r10rxxxx"
    LCP_Data |= (1 << 5);
}


/**
 * Функция для копирования передаваемого объекта transferObject - в виде байтового массива
 * в пакет LCP_sendPacket для передачи пакетов через Link cable
 * первые 2 байта в пакете содержат тип передаваемого объекта (не может быть равен 0)
 * далее в пакете идут данные (по 2 байта) объекта, согласно таблице размеров объектов objectTypeSizes
 * можно передавать несколько объектов за раз, главное чтоб они влезли в буфер
 * т.е. предполагается что функцию можно вызывать несколько раз подряд, пока не получим
 * ниже описанные ошибки
 *
 * если error & 0x000F == 0xC - размер передаваемого объекта отрицательный либо равен 0
 * если error & 0x000F == 0xD - размер передаваемого объекта больше оставшегося места в пакете
 * если error & 0x000F == 0xF - индекс начала данных в пакете больше индекса конца данных в пакете
 *
 * transferObject - отправляемый объект в виде байтового массива через Link cable
 * objectType - тип отправляемого объекта (число равеное номеру в массиве размеров объектов)
 * objectTypeSizes - массив размеров объектов (определяется в основном коде ВАШЕЙ игры)
 */
void LCP_objectToPacketForSend(u8 *transferObject, u16 objectType , u16 *objectTypeSizes) {
    // размер передаваемого объекта из массива размеров объектов
	u16 objectSize = objectTypeSizes[objectType];
	// индекс окончания данных в пакете для отправки LCP_sendPacket
	u16 tail = LCP_sendTail;
	// // индекс начала данных данных в пакете для отправки LCP_sendPacket
	u16 head = LCP_sendHead;

	// проверяем что размер передаваемого объекта больше 0
    if (objectSize <= 0) {
    	// 0xC - размер передаваемого объекта отрицательный либо равен 0
    	LCP_error = 0xC;

    	// выходим из функции с ошибкой в LCP_error
        return;
    }

    // проверяем что не выйдем за границы массива LCP_sendPacket при отправке объекта
    if (objectSize > LCP_PACKET_SIZE - head) {
    	// 0xD - размер передаваемого объекта больше оставшегося места в пакете
    	LCP_error = 0xD;

    	// выходим из функции с ошибкой в LCP_error
        return;
    }

    // проверяем что индекс начала данных не больше индекса конца данных в пакете
    if (head > tail) {
    	// 0xF - индекс начала данных в пакете больше индекса конца данных в пакете
    	LCP_error = 0xF;
    	LCP_clearSendHeadAndTail();
    	// выходим из функции с ошибкой в LCP_error
        return;
    }

    // первые 2 байта (16 бит) данных пакета будут содержать тип передаваемого объекта
    LCP_sendPacket[tail] = objectType;

    // нужно увеличить индекс конца данных в пакете на 1
    tail++;

    // копируем передаваемый объект transferObject в пакет для передачи данных - LCP_sendPacket, начиная с индекса
    // tail размером objectSize
    memcpy(LCP_sendPacket + tail, transferObject, objectSize);

    // обновляем значение индекса конца данных в пакете LCP_sendPacket
    LCP_sendTail = tail + objectSize;
}


/**
 * Функция достает очередной объект в виде байтового массива transferObject из полученного пакета LCP_recivePacket
 * через Link cable и возвращает тип этого объекта или 0 если объект не удалось достать из LCP_recivePacket
 * т.к. мы можем за 1 раз передать несколько объектов, предполагается возможным несколько раз подряд
 * вызывать данную функцию, пока не получем 0, что занчит - все объекты извлечены из переданного пакета
 *
 * первые 2 байта пакета в LCP_recivePacket содержат тип передаваемого объекта (не может быть равен 0)
 * далее в пакете идут данные (по 2 байта) объекта, согласно таблице размеров объектов objectSizes
 * можно передавать несколько объектов за раз, главное чтоб они влезли в массив LCP_recivePacket
 *
 * если error & 0xF000 == 0x1000 - нет объекта в полученном пакете, все дастали уже из пакета или нам ни чего не передали
 * если error & 0xF000 == 0x2000 - размер извлекаемго объекта из буфера прочитанных пакетов - отрицательный или равен 0
 * если error & 0xF000 == 0x3000 - размер извлекаемого объекта больше оставшихся данных в пакете полученных данных
 * если error & 0xF000 == 0x4000 - размер извлекаемого объекта больше оставшегося размера массива LCP_recivePacket
 *
 * transferObject - очередной полученный объект в виде байтового массива через Link cable
 * objectSizes - массив размеров объектов (определяется в основном коде ВАШЕЙ игры)
 *
 * return - тип полученного объекта или 0 если не удалось извлечь объект из полученного пакета
 */
u16 LCP_getNextObjectFromRecivePacket(u8 *transferObject, u16 *objectSizes) {
	// текущий индекс в полученном пакете с которого начнем читать данные
    u16 head = LCP_reciveHead;
    // индекс конца данных в полученном пакете
    u16 tail = LCP_reciveTail;
    // тип объекта который вернет функция или 0 если ни какой объект не был найден в полученном пакете
    u16 objectType;
    // размер объекта из массива размеров объектов согласно типу объекта
    u16 objectSize = 0;

    // Проверка наличия данных в полученном пакете (что начало данных не совпадает с концом данных)
    if (head >= tail) {
    	// 0x1000 - нет объекта в полученном пакете, все дастали уже из пакета или нам ни чего не передали
    	LCP_error |= 0x1000;
    	// Нет данных, возвращаем 0 (ни какой объект не смогли достать)
        return 0;
    }

    // читаем первый байт - тип объекта
    // предполагается, что paketSizes объявлена где-то в коде ВАШЕЙ игры !!!
    objectType = LCP_recivePacket[head];

    // т.к. прочитали тип объекта надо сдвинуть индекс начала данных на 1
    head++;

    // получаем размер объекта по его типу из таблицы размеров объектов
    objectSize = objectSizes[objectType];

    // если размер объекта отрицательный или равен 0 - ошибка!
    if (objectSize <= 0) {
    	// 0x2000 - размер извлекаемго объекта из буфера прочитанных пакетов - отрицательный или равен 0
    	LCP_error |= 0x2000;
    	// Нет данных, возвращаем 0 (ни какой объект не смогли достать)
        return 0;
    }

    // Если размер объекта больше оставшихся данных в буфере чтения - ошибка!
    if (objectSize > tail - head) {
    	// 0x3000 - размер извлекаемого объекта больше оставшихся данных в пакете полученных данных
    	LCP_error |= 0x3000;
    	// Нет данных, возвращаем 0 (ни какой объект не смогли достать)
        return 0;
    }

    // Если размер объекта выходит за оставшийся размер массива для пакета получения данных
    if (objectSize > LCP_PACKET_SIZE - head) {
    	// 0x4000 - размер извлекаемого объекта больше оставшегося размера массива LCP_recivePacket
    	LCP_error |= 0x4000;
    	// Нет данных, возвращаем 0 (ни какой объект не смогли достать)
        return 0;
    }

    // копируем в байтовый массив transferObject из полученного пакета LCP_recivePacket начиная с нидекса head
    // objectSize байт, т.е. целиком объект из LCP_recivePacket в transferObject.
    memcpy(transferObject, LCP_recivePacket + head, objectSize);

    // т.к. извлекли очередной объект из пакета, перемещаем индекс начала не извлесенных объектов в пакете
    // на head + objectSize, то откуда при следующем вызове LCP_getNextObjectFromRecivePacket будем извлекать
    // очередной объект
    LCP_reciveHead = head + objectSize;

    if (LCP_reciveHead == LCP_reciveTail) {
    	// если все было прочитано можно сброить LCP_reciveHead и LCP_reciveTail в 0
    	LCP_clearReciveHeadAndTail();
    }

    // возвращаем тип объекта прочитанного в transferObject из полученного пакета LCP_recivePacket
    return objectType;
}


/**
 * Цикл передачи а затем получения данных через Link cable ведущей приставки SEGA (master)
 * в самом начале отключает обработку всех прирываний и сбрасываем LCP_timeOut и LCP_error в 0
 * и в случае ошибки и в случае успешном завершении функции, т.е. всегда в конце вызываем LCP_masterCycleEnd()
 * чтоб перевести 2 порт приставки в правильное состояние и включить обработку всех прерываний.
 *
 * если LCP_error & 0x00F0 = 0x10 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x20 - ошибка при вызове функции LCP_send(size) - передачи 2 байт (размера пакета) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x30 - ошибка при вызове функции LCP_send(data) - передачи 2 байт (данные пакета) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x40 - ошибка при вызове функции LCP_send(checksum) - передачи 2 байт (контрольной суммы) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x50 - ошибка при вызове функции LCP_endSendCycle() - конеца основного цикла передачи пакета от ведущей (master) ведомой (slave) приставке
 * если LCP_error & 0x00F0 = 0x60 - ошибка при вызове функции LCP_startReciveCycle() - начала цикл получения данных от ведомой приставки (slave) ведущей
 * если LCP_error & 0x00F0 = 0x70 - ошибка при вызове функции data = LCP_recive() - получение 2 байт (контрольной суммы пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0x80 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0x90 - ошибка при вызове функции size = LCP_recive()- получения 2 байт (размер пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xA0 - ошибка при вызове функции data = LCP_recive() - получения 2 байт (данные пакета) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xB0 - ошибка при вызове функции data = LCP_recive() - основной цикл получения 2 байт (checksum) от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xC0 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xD0 - ошибка при вызове функции LCP_endReciveCycle() - окончание цикла получения данных от ведомой приставки (slave)
 * если LCP_error & 0x00F0 = 0xE0 - ошибка при вызове функции LCP_startSendCycle() -  начало передачи контрольной суммы ведомой (slave) от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0xF0 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы ведомой (slave) от ведущей (master)
 */
void LCP_masterCycle() {
	// размер передаваемых или получаемых данных
	s16 size;
	// контрольная сумма для проверки переданных данных
	u16 checksum;
	// текущий индекс передаваемых или получаемых данных
	u16 head;
	// передаваемые или полученные 2 байта (16 бит) через Link cable Protocol
	u16 data;

    // выключаем обработку прерываний
	SYS_disableInts();

	// Очистка таймаута
    LCP_timeOut = 0;
    // Очистка ошибок
	LCP_error = 0;

    // начало цикла передачи данных через Link cable от основной приставки (master) ведомой приставке (slave)
	// вызов внешнего прерывания External interrupt (EX-INT) у ведомой приставки (slave)
    LCP_startSendCycle();

    if (LCP_timeOut) {
    	// 0x10 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведущей приставки (master)
    	LCP_error |= 0x10;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // вычисляем размер данных которые нужно передать на основе индекса конца и начала данных в пакете для передачи
    size = LCP_sendTail - LCP_sendHead;
    if (size < 0) {
    	// если размер меньше 0, то обнуляем и индексы и размер передаваемых данных
    	LCP_clearSendHeadAndTail();
        size = 0;
    }

    // отправляем размер пакета данных ведомой привтаке (slave) через Link cable от ведущей приставки (master)
    LCP_send(size);

    if (LCP_timeOut) {
    	// 0x20 - ошибка при вызове функции LCP_send(size) - передачи 2 байт (размера пакета) от ведущей приставки (master)
    	LCP_error |= 0x20;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // сброс контрольной суммы
    checksum = 0;

    // индекс в буфере передачи данных устанавливаем на начало данных в LCP_sendPacket
    head = LCP_sendHead;

	// передаем данные, если размер больше 0 (есть что передавать)
	for (u16 i = 0; i < size; i++) {
		// извлекаем из пакета данных для отправки очередные 2 байта
		data = LCP_sendPacket[head];
		// индекс в буфере передачи данных увеличиваем на 1
		head++;
		// вычисляем контрольную сумму для проверки успешности передачи данных
		checksum += data;
		// отправляем очередные 2 байта через Link cable ведомой приставке (slave)
		LCP_send(data);

		if (LCP_timeOut) {
			// 0x30 - ошибка при вызове функции LCP_send(data) - передачи 2 байт (данные пакета) от ведущей приставки (master)
			LCP_error |= 0x30;
			LCP_masterCycleEnd();
			// Завершаем выполнение функции с ошибкой, LCP_error != 0
			return;
		}
	}

	// передаем другой приставке контрольную сумму для проверки ранее переданных данных
    LCP_send(checksum);

    if (LCP_timeOut) {
    	// 0x40 - ошибка при вызове функции LCP_send(checksum) - передачи 2 байт (контрольной суммы) от ведущей приставки (master)
    	LCP_error |= 0x40;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }
    // завершение цикла передачи данных через Link cable от ведущей приставки (master) к ведомой приставке (slave)
    LCP_endSendCycle();

    if (LCP_timeOut) {
    	// 0x50 - ошибка при вызове функции LCP_endSendCycle() - конеца основного цикла передачи пакета от ведущей (master) ведомой (slave) приставке
    	LCP_error |= 0x50;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // начало получения данных от ведомой SEGA в основном цикле
    LCP_startReciveCycle();

    if (LCP_timeOut) {
    	// 0x60 - ошибка при вызове функции LCP_startReciveCycle() - начала цикл получения данных от ведомой приставки (slave) ведущей
    	LCP_error |= 0x60;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // читаем первые 2 байта от ведомой приставки (slave)
    data = LCP_recive();

    if (LCP_timeOut) {
    	// 0x70 - ошибка при вызове функции data = LCP_recive() - получение 2 байт (контрольной суммы пакета) от ведомой приставки (slave)
    	LCP_error |= 0x70;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // проверяем что полученная сумма от ведомой приставки равна чексумме расчитанной в оснвном цикле
    if (data == checksum) {
    	// данные успешно получены ведемой SEGA
    	// индекс начала данных которые необходимо передать устанавливаем на конец данных в буфере
	    LCP_sendHead = LCP_sendTail;
    } else {
		// 0x80 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
		LCP_error |= 0x80;
		// не прерываем функцию т.к. таймаута небыло, пытаемся получить данные от ведомой приставки (slave)
		// TODO если получили 0x80 надо перепослать пакет по хорошему
	}

    // сбрасываем контрольную сумму
    checksum = 0;

    // получаем первые 2 байта от ведомой приставки (slave)
    // в size 2 байта что были получены от ведомой приставки (slave) т.к. там размер пакета данных лежит
    size = LCP_recive();

    if (LCP_timeOut) {
    	// 0x90 - ошибка при вызове функции size = LCP_recive()- получения 2 байт (размер пакета) от ведомой приставки (slave)
    	LCP_error |= 0x90;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // текущий индекс на начало данных в LCP_recivePacket
    head = LCP_reciveTail;

	// получаем данные если размер больше 0 (есть что получать)
	for (u16 i = 0; i < size; i++) {
		// получаем очередные 2 байта от ведомой приставки (slave) через Link cable
		data = LCP_recive();

		if (LCP_timeOut) {
			// 0xA0 - ошибка при вызове функции data = LCP_recive() - получения 2 байт (данные пакета) от ведомой приставки (slave)
			LCP_error |= 0xA0;
			LCP_masterCycleEnd();
			// Завершаем выполнение функции с ошибкой, LCP_error != 0
			return;
		}

		// вычисляем контрольную сумму
		checksum += data;

		// сохраняем прочитанные 2 байта в пакет полученных объектов данных
		LCP_recivePacket[head] = data;

		// изменяем индекс текущей позиции пакете полученных объектов данных
		head++;
	}

    // получаем контрольную сумму от ведомой приставки (slave)
    data = LCP_recive();

    if (LCP_timeOut) {
    	// 0xB0 - ошибка при вызове функции data = LCP_recive() - основной цикл получения 2 байт (checksum) от ведомой приставки (slave)
    	LCP_error |= 0xB0;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // проверяем что полученная контрольная сумма от ведомой приставки (slave) равна расчитанной
    if (data == checksum) {
    	// устанавливаем индекс конца данных на текущий индекс в буфере полученных данных
	    LCP_reciveTail = head;
	} else {
		// 0xC0 - контрольная сумма расчитанная ведущей приставкой (master) <> контрольной сумме полученной от ведомой приставки (slave)
		LCP_error |= 0xC0;
		// поэтому не перемещаем индекс конца для пакета полученных данных LCP_recivePacket
		// но так как небыло таймаутов продолжаем выполнени функции
	}

    // оканчание получения данных от ведомой приставки (slave)
    LCP_endReciveCycle();

    if (LCP_timeOut) {
    	// 0xD0 - ошибка при вызове функции LCP_endReciveCycle() - окончание цикла получения данных от ведомой приставки (slave)
    	LCP_error |= 0xD0;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, error != 0
    	return;
    }

    // начало передачи данных ведомой преставке (slave) от ведущей (master)
    LCP_startSendCycle();

    if (LCP_timeOut) {
    	// 0xE0 - ошибка при вызове функции LCP_startSendCycle() -  начало передачи контрольной суммы ведомой (slave) от ведущей приставки (master)
    	LCP_error |= 0xE0;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // отправляем контрольную сумму ведомой приставке (slave) от ведущей (master)
    LCP_send(checksum);

    if (LCP_timeOut) {
    	// 0xF0 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы ведомой (slave) от ведущей (master)
    	LCP_error |= 0xF0;
    	LCP_masterCycleEnd();
    	// Завершаем выполнение функции с ошибкой, LCP_error != 0
    	return;
    }

    // заканчиваем передачу данных
    LCP_endSendCycle();

    // заканчиваем передачу/получение пакета
    LCP_masterCycleEnd();
}


/**
 * Окончание цикла передпчи и получения данных через Link cable ведущей приставки SEGA (master)
 * переводит 2 порт приставки в режим получения данных через Link cable, на всех пинах кроме 5 го
 * У LCP_Ctrl выставляем бит 5 в 1 остальные в 0 что означает что мы больше не передаем данные в 0 - 3 битах
 * у LCP_Data выставляем бит 5 в 1 для нашей ведущей (master) приставки, у другой приставки (slave) бит 6 станет тоже 1
 * включает обратно обработку всех прерываний
 */
static void LCP_masterCycleEnd() {
    // переводим порт в режим получения данных
	// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала другой приставке о событии (у другой 6 бит LCP_Data будет равен тому что мы у нашей выставили в 5ом)
    // pin 6 сигнал от другой приставки о событии (другая приставка должна менять 5 бит у своей LCP_Data чтоб у нашей менялся 6ой)
    LCP_Ctrl = LCP_BIT5;

    // выставляем 5 бит у LCP_Data в 1
    LCP_Data |= (1 << 5);

    /** TODO удалить или поднастроить
    if (LCP_timeOut) {
    	uint8_t timeout = LCP_timeOutTime;
    	if (timeout > 0) {
			while (timeout > 0) {
				for (int i = 0; i < 10; i++) {
					asm volatile ("nop"); // Ожидание
				}
				timeout--;
			}
    	}

       LCP_timeOutTime+= 30;
    } else {
       // Очистка времени таймаута
       LCP_timeOutTime = 0;
    }
   */


   // включаем обработку всех прерываний
   SYS_enableInts();
}


/**
 * Цикл получения а затем передачи данных через Link cable ведомой приставки SEGA (slave)
 * Это обработчик внешнего прерывания EX-INT - External interrupt в документации SEGA
 * вызывать напрямую из кода игры его НЕЛЬЗЯ!
 *
 * Данная функция будет установлена в качестве обработчика внешних прирываний EX-INT при вызове функции LCP_open() из ВАШЕГО кода игры
 * и в качестве обработчика внешних прерываний будет отключена при вызове LCP_close() из ВЫШЕГО кода игры
 *
 * вызов функции всегда происходит как бы асинхронно, прерывая выполнение вашего кода игры в произвольное, рандомное время для основного кода игры!
 *
 * в самом начале отключает обработку всех прирываний и сбрасываем LCP_timeOut и LCP_error в 0
 *
 * если LCP_error & 0x0F00 = 0x100 - ошибка при вызове функции LCP_slaveCycle() - второй порт приставки не открыт для обмена данными
 * если LCP_error & 0x0F00 = 0x200 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x300 - ошибка при вызове функции size = LCP_recive() - получение размера переданных данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x400 - ошибка при вызове функции data = LCP_recive() - получение очередных 2 байта даных пакета от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x500 - ошибка при вызове функции data = LCP_recive() - получение контрольной суммы от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0x80  - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x600 - ошибка при вызове функции LCP_endReciveCycle() - конец получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0x700 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0x800 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0x900 - ошибка при вызове функции LCP_send(size) - передача размера передаваемого пакета от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xA00 - ошибка при вызове функции LCP_send(data) - передача очередных 2 байт данных из пакета от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xB00 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xC00 - ошибка при вызове функции LCP_endSendCycle() - конец передачи данных от ведомой приставки (slave)
 * если LCP_error & 0x0F00 = 0xD00 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
 * если LCP_error & 0x0F00 = 0xE00 - ошибка при вызове функции data = LCP_recive() - получения контрольной суммы от ведущей приставки (master)
 * если LCP_error & 0x00F0 = 0xC0  - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
 */
static void LCP_slaveCycle() {
	// размер передаваемых или получаемых данных
	s16 size;
	// контрольная сумма для проверки переданных данных
	u16 checksum = 0;
	// текущий индекс передаваемых или получаемых данных
	u16 head = LCP_reciveTail;
	// передаваемые или полученные 2 байта (16 бит) через Link Cable
	u16 data;

	LCP_error = 0;
	LCP_timeOut = 0;

    // переводим порт в режим чтения данных
	// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала другой приставке о событии (у другой 6 бит LCP_Data будет равен тому что мы у нашей выставили в 5ом)
    // pin 6 сигнал от другой приставки о событии (другая приставка должна менять 5 бит у своей LCP_Data чтоб у нашей менялся 6ой)
    LCP_Ctrl = LCP_BIT5;

    if (!LCP_portOpen) {
    	// порт не открыт
    	// 0x100 - ошибка при вызове функции LCP_slaveCycle() - второй порт приставки не открыт для обмена данными
    	LCP_error |= 0x100;
        return;
    }

    // отключаем обработку всех прерываний
    SYS_disableInts();

    // начинаем цикл получения данных нашей ведомой приставкой (slave) через Link Cable от ведущей приставки (master)
    LCP_startReciveCycle();

    if (LCP_timeOut) {
    	// 0x200 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
    	LCP_error |= 0x200;
    	LCP_slaveCycleEnd();
    	return;
    }

    // первые 2 байта данных - размер пакета переданных нашей приставке (slave) через Link Cable от ведущей привтавки (master)
    size = LCP_recive();

    if (LCP_timeOut) {
    	// 0x300 - ошибка при вызове функции size = LCP_recive() - получение размера переданных данных от ведущей приставки (master)
    	LCP_error |= 0x300;
    	LCP_slaveCycleEnd();
    	return;
    }

    // получаем тело пакета от ведущей приставки (master) через Link Cable нашей приставкой (slave)
	for (u16 i = 0; i < size; i++) {
		// получить 2 байта данных в data нашей ведомой приставкой (slave) через Link Cable от ведущей приставки (master)
		data = LCP_recive();

		if (LCP_timeOut) {
			// 0x400 - ошибка при вызове функции data = LCP_recive() - получение очередных 2 байта даных пакета от ведущей приставки (master)
			LCP_error |= 0x400;
			LCP_slaveCycleEnd();
			return;
		}

		// вычисляем проверочную сумму
		checksum += data;
		// сохраняем полученные 2 байта в получаемый пакет по интексу head
		LCP_recivePacket[head] = data;
		// увеличиваем head - индекс начала данных в LCP_recivePacket на 1
		head++;
	}

	// после тела пакета получаем контрольную сумму отправленных данных в data от ведущей приставки (master)
    data = LCP_recive();

    if (LCP_timeOut) {
    	// 0x500 - ошибка при вызове функции data = LCP_recive() - получение контрольной суммы от ведущей приставки (master)
    	LCP_error |= 0x500;
    	LCP_slaveCycleEnd();
    	return;
    }

    // если проверачная сумма полученная от ведущей приставки (master) в data равна вычесленной нами
    // то сохраняем индекс head в глобальную переменную LCP_reciveTail - индекс конца данных полученного пакета
    // от ведущей приставки (master)
    if (data == checksum) {
    	LCP_reciveTail = head;
	} else {
		// если LCP_error & 0x00F0 = 0x80 - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
		LCP_error |= 0x80;
		// не прерываем функцию т.к. таймаута небыло, пытаемся отправить данные от нашей ведомой приставки (slave) ведущей (master)
		// TODO если получили 0x80 надо перепослать пакет по хорошему но ДРУГОЙ приставкой
	}

    // конец цикла получения данных нашей ведомой приставкой (slave) от ведущей приставки (master) через Link Cable
    LCP_endReciveCycle();

    if (LCP_timeOut) {
    	// 0x600 - ошибка при вызове функции LCP_endReciveCycle() - конец получения данных от ведущей приставки (master)
    	LCP_error |= 0x600;
    	LCP_slaveCycleEnd();
    	return;
    }

    // начинаем цикл передачи данных от нашей ведомой приставки (slave) через Link Cable ведущей приставке (master)
    LCP_startSendCycle();

    if (LCP_timeOut) {
    	// 0x700 - ошибка при вызове функции LCP_startSendCycle() - начала передачи данных от ведомой приставки (slave)
    	LCP_error |= 0x700;
    	LCP_slaveCycleEnd();
    	return;
    }

    // передаем вычесленную контрольную сумму ведущей приставке (master) от нашей ведомой приставки (slave) через Link Cable
    LCP_send(checksum);

    if (LCP_timeOut) {
    	// 0x800 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
    	LCP_error |= 0x800;
    	LCP_slaveCycleEnd();
    	return;
    }

    // вычисляем размер пакета который надо передать
    size = LCP_sendTail - LCP_sendHead;
    if (size < 0) {
    	size = 0;
    	LCP_clearSendHeadAndTail();
    }

    // отправляем размер тела пакета от нашей ведомой приставки (slave) через Link Cable ведущей приставке (master)
	LCP_send(size);

	if (LCP_timeOut) {
		// 0x900 - ошибка при вызове функции LCP_send(size) - передача размера передаваемого пакета от ведомой приставки (slave)
		LCP_error |= 0x900;
    	LCP_slaveCycleEnd();
    	return;
    }

	// сбрасываем значение контрольной суммы
	checksum = 0;

	// устанавливаем индекс head на начало пакета который надо передать
	head = LCP_sendHead;

	// отправляем тело пакета от нашей приставки (slave) через Link Cable ведущей приставке (master)
	for (u16 i = 0; i < size; i++) {
		// в data записываем 2 байта которые будем передавать из пакета от ведомой приставки (slave)
		data = LCP_sendPacket[head];

		// увеличиваем индекс head на 1 начала данных в LCP_sendPacket которые надо отправить
		head++;

		// вычисляем проверочную сумму
		checksum += data;

		// отправляем 2 байта тела пакета от нашей ведомой приставки (slave) через Link Cable ведущей приставке (master)
		LCP_send(data);

		if (LCP_timeOut) {
			// 0xA00 - ошибка при вызове функции LCP_send(data) - передача очередных 2 байт данных из пакета от ведомой приставки (slave)
			LCP_error |= 0xA00;
			LCP_slaveCycleEnd();
			return;
		}
	}

	// после тела пакета отправляем контрольную сумму отправленных данных пакета
	// от нашей ведомой приставки (slave) через Link Cable ведущей приставке (master)
    LCP_send(checksum);

    if (LCP_timeOut) {
    	// 0xB00 - ошибка при вызове функции LCP_send(checksum) - передача контрольной суммы от ведомой приставки (slave)
    	LCP_error |= 0xB00;
    	LCP_slaveCycleEnd();
    	return;
    }

    // завершаем цикл отправки данных от нашей ведомой приставки (slave) через Link Cable ведущей приставке (master)
    LCP_endSendCycle();

    if (LCP_timeOut) {
    	// 0xC00 - ошибка при вызове функции LCP_endSendCycle() - конец передачи данных от ведомой приставки (slave)
    	LCP_error |= 0xC00;
    	LCP_slaveCycleEnd();
    	return;
    }

    // начинаем цикл получения данных нашей ведомой приставкой (slave) через Link Cable от ведущей приставки (master)
    LCP_startReciveCycle();

    if (LCP_timeOut) {
    	// 0xD00 - ошибка при вызове функции LCP_startReciveCycle() - начала получения данных от ведущей приставки (master)
    	LCP_error |= 0xD00;
    	LCP_slaveCycleEnd();
    	return;
    }

    // получаем контрольную сумму полученных данных ведущей приставкой (master) через Link Cable от нашей ведомой приставки (slave)
    data = LCP_recive();

    if (LCP_timeOut) {
    	// 0xE00 - ошибка при вызове функции data = LCP_recive() - получения контрольной суммы от ведущей приставки (master)
    	LCP_error |= 0xE00;
    	LCP_slaveCycleEnd();
    	return;
    }

    // если полученная контрольная сумма в data от ведущей приставки (master) равна переданой и вычисленной нашей приставкой (slave)
    // то устанавливаем индекс начала пакета на индекс конца пакета (все удачно отправили)
    if (data == checksum) {
	    LCP_sendHead = LCP_sendTail;
	} else {
		// 0xC0 - контрольная сумма расчитанная ведомой приставкой (slave) <> контрольной сумме полученной от ведущей приставки (master)
		LCP_error |= 0xC0;
		// поэтому не перемещаем индекс начала для пакета полученных данных LCP_sendPacket
		// но так как небыло таймаутов продолжаем выполнени функции
	}

    // конец цикла получения данных нашей ведомой приставкой (slave) от ведущей приставки (master) через Link Cable
    LCP_endReciveCycle();

    // конец взаимодействия приставок в этом цикле со стороны нашей ведомой
    LCP_slaveCycleEnd();
}


/**
 * Конец цикла получения а затем передачи данных через Link cable ведомой приставки SEGA (slave)
 * переводит 2 порт приставки в режим получения данных через Link cable, на всех пинах кроме 5 го
 * У LCP_Ctrl выставляем бит 5 в 1 остальные в 0 что означает что мы больше не передаем данные в 0 - 3 битах
 * у LCP_Data выставляем бит 5 в 1 для нашей ведомой (slave) приставки, у другой приставки (master) бит 6 станет тоже 1
 * включает обратно обработку всех прерываний
 *
 * если LCP_error & 0x0F00 = 0xF00 - шибка при вызове функции LCP_slaveCycleEnd() - окончание цикла получения данных от ведомой приставки (slave)
 */
static void LCP_slaveCycleEnd() {
	// TODO это можно еще подбирать
    //if (LCP_timeOut) {
    //	LCP_timeOutTime += 5;
    //} else {
    //    LCP_timeOutTime = 0;
    //}


    // переводим порт в режим чтения данных
	// Прерывание по сигналу линии SYN запрещено, 7 бит = 0.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала другой приставке о событии (у другой 6 бит LCP_Data будет равен тому что мы у нашей выставили в 5ом)
    // pin 6 сигнал от другой приставки о событии (другая приставка должна менять 5 бит у своей LCP_Data чтоб у нашей менялся 6ой)
    LCP_Ctrl = LCP_BIT5;

    // выставляем 5 бит у LCP_Data в 1
    LCP_Data |= (1 << 5);

    u16 timeout = LCP_TIME_OUT;
    do {
        timeout--; // Вычитаем 1 из d5
        if (timeout == 0) {
            LCP_timeOut++;
            // 0xF00 - ошибка при вызове функции LCP_slaveCycleEnd() - окончание цикла получения данных от ведомой приставки (slave)
            LCP_error |= 0xF00;
			// Если timeout стал равен 0, выходим из цикла
            break;
        }
    	// ждем пока 6 бит не станет 1
    } while (!(LCP_Data & (1 << 6)));

	// готовы к обмену данными через 2 порт приставки по наступлению EX-INT прерывания
	// сначала чтения данных из порта потом записи в порт в обработчике внешних прерываний LCP_slaveCycle()
	// Прерывание по сигналу линии SYN разрешено, 7 бит = 1.
	// линия данных PC5 в режиме вывода (отправки), 5 бит = 1.
	// линии данных PC6, PC4, PC3, PC2, PC1, PC0 в режиме ввода (получения). Соответствующие биты = 0
    // включаем pin 0-3 2го порта контроллера для получения данных
    // pin 5 для сигнала о том что данные получены нашей приставкой (у другой приставки это 6 бит LCP_Data будет)
	// pin 6 сигнал о том что данные были отправлены другой приставкой (другая приставка должна менять 5 бит у своей LCP_Data)
    LCP_Ctrl = LCP_BIT7_AND_BIT5;

    // включаем обработку всех прерываний
	SYS_enableInts();
}


/**
 * return LCP_sendHead
 */
u16 LCP_getSendHead() {
	return LCP_sendHead;
}


/**
 * return LCP_sendTail
 */
u16 LCP_getSendTail() {
	return LCP_sendTail;
}


/**
 * Возвращает индекс начала данных в массиве LCP_recivePacke
 *
 * return LCP_reciveHead
 */
u16 LCP_getReciveHead() {
	return LCP_reciveHead;
}


/**
 * Возвращает индекс конеца данных в массиве LCP_recivePacket
 *
 * return u16 LCP_reciveTail
 */
u16 LCP_getReciveTail() {
	return LCP_reciveTail;
}


/**
 * Ошибка при передачи данных через SEGA Link cable
 *
 * return LCP_error
 */
u16 LCP_getError() {
	return LCP_error;
}

